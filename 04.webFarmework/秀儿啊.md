## 多用组合少用继承
  因为继承相对耦合性更高

## 推和栈的区别
  栈是数据结构，
  推是内存空间,内存申请时是以推为单位，内存的分配是有内存回收器定义的

## yield
  yield 语义是转让执行控制权

# 秀儿
## 优秀的工程师，是可以直接面向结果去做事情的，哪怕他没有这个技能
## 在上层用简单的逻辑处理复杂的交互，底层会有大量架构操作
## 通常订阅函数都要返回一个取消订阅的功能函数，为什么呢？
  > 取消订阅的权限必须是订阅者所有的，所以必须给订阅者返回一个取消订阅函数，并且，这是一个及其优雅的设计
  
## 查看端口
  `netstat -ano`
  windows `netstat -ano | findstr 7001` 查看占用7001端口的进程
  linux `netstat -ano | grep 7001` 查看占用7001端口的进程
## DSL -> Domain specific Language 领域专有语言
## promise是个异步的解决方案，是个可能发生在未来的值。 其本质是个状态机
## if-else 是 control Flow - 控制流
## switch 是 pattern Matching - 模式匹配

## 任何的程序设计都不能以损失人力阅读成本为代价来优化性能
## 领域化模型可以解耦领域对象与渲染层，领域层的可扩展性与抽象能力是非常强大的

## 用一套resful架构api，不需要文件中存大量url

## 控制反转、AOP、依赖注入
控制反转：把控制权交出去，由其他人实现具体函数，
AOP：切分函数关注点，不同的关注点由不同的切面完成，
依赖注入：可以使程序不再需要过多的硬编码，而是通过依赖注入完成属性注入

# vue 没使用fiber这种架构，带来的弊端就是在大型项目上性能不够

# 本地的link打包的时候 不会被打包进项目！！！！我的天呀！！！

# 面向对象与函数式编程
  * 面向对象与函数式都是类型
  * 函数式编程是声明式的一种类型，声明式强调目标而不是具体过程。
  * 面向对象中的接口 函数式中叫做类型类 typesClass
  * 面向对象与函数式的理论模型都是为了解决可计算问题
  javascript 支持面向对象编程范式也支持函数式编程范式，但是其主要是面向对象的

# for of用来遍历迭代器的值。for in 用来遍历可枚举对象的key,包括其原型链上的可枚举的key

# array.constructor === Array  可用来判断对象是不是数组

console.log(path.resolve())
console.log(__dirname) //当前文件所在路径
console.log(process.cwd()) // 用户执行脚本所在路径

# 用属性+方法来代替函数+数据
函数 = 行为；

函数加数据 会把行为与数据分离，无法做到逻辑内聚，集中管理

类；用类的方法代替函数，用类的属性代替数据，把行为+数据 改成 属性+方法。做到了逻辑内聚，集中管理

* 使用类还是函数的判断可以用否需要计算来判别


扎实的coding能力 超强的学习能力 资深的团代搭建经验

# 轻代码平台不是没代码，而是ui层没代码，代码都提前编写好了在数据库放着呢！

# 前缀和

前缀和数组中两个位置相减，可以快速求得原序列的区间和
let a = [1,2,3,4,5]
let sum = [0,1,3,6,10,15]
let j=1,i=5
sum[j] 到 sum[i] 相减得14。 
原序列j 到i-1的区间和就是14

# 自定义hook原则
  1. 数据驱动
     * 没有任何的外部数据流入，也没有数据流出，完全可以将其抽象为一个高阶函数，而不是一个自定义 Hooks。
     * 因此具有复用价值且与外部存在数据驱动关系的功能模块才有必要抽象为自定义 Hooks。
  2. 单一原则

# TCP重试有没有可能导致重复下单
  答案是不会的。这个在TCP那一节有详细的讲解。因为TCP层收到了重复包之后，TCP层自己会进行去重，发给应用层、HTTP层。还是一个唯一的下单请求，所以不会重复下单。

  那什么时候会导致重复下单呢？因为网络原因或者服务端错误，导致TCP连接断了，这样会重新发送应用层的请求，也即HTTP的请求会重新发送一遍。

  如果服务端设计的是无状态的，它记不住上一次已经发送了一次请求。如果处理不好，就会导致重复下单，这就需要服务端除了实现无状态，还需要根据传过来的订单号实现幂等，同一个订单只处理一次。

  还会有的现象是请求被黑客拦截，发送多次，这在HTTPS层可以有很多种机制，例如通过 Timestamp和Nonce随机数联合起来，然后做一个不可逆的签名来保证。

# 应用启动后在内存中形成进程 - 所以进程就是应用程序的副本

# 多路复用 - 多路信号在一个信道中进行通信

# 获取指定位置的最上层元素
```js
  document.elementFromPoint(0, 0)// 获取指定位置的最上层元素
```

## OSS 与 CDN 

OSS 是一个对象存储数据库 - 提供一个接口用来获取数据

用户请求CDN -> CDN 使用接口回源 OSS

## 代码复用来带的坏处
  复用的越是优雅，改动时就越是痛苦

## 封装是希望通过增加内部的复杂度来减少外部的复杂度

### Race Condition
  基于闭包读值会出现**竞争条件**的问题
  最终的结果取决于程序执行的精准时序

## Q&A
Q: 前端代码从 tsx/jsx 到部署上线被用户访问，中间大致会经历哪些过程？
A: 经历本地开发、远程构建打包部署、安全检查、上传CDN、Nginx做流量转发、对静态资源做若干加工处理等过程。

Q：可能大部分同学都知道强缓存/协商缓存，那前端各种产物（HTML、JS、CSS、IMAGES 等）应该用什么缓存策略？以及为什么？

* 若使用协商缓存，但静态资源却不频繁更新，如何避免协商过程的请求浪费？

* 若使用强缓存，那静态资源如何更新？

A：**HTML使用协商缓存，静态资源使用强缓存**，使用name-hash（非覆盖式发布）解决静态资源更新问题。

Q：如何避免前端上线，影响未刷新页面的用户？
A：使用name-hash方式组织静态资源，**先上线静态资源，再上线HTML**。

Q：刚上线的版本发现有阻塞性 bug，如何做到秒级回滚，而非再次部署等 20 分钟甚至更久？
A1：HTML文件使用非覆盖方式存储在CDN上，搭建前端发布服务，对 HTML 按版本等做缓存加工处理。当需要回滚时，更改发布服务HTMl指向即可。
A2: 直接回滚构建文件即可

Q: CDN 域名突然挂了，如何实现秒级 CDN 降级修补而非再次全部业务重新部署一次？
A1: 将静态资源传输到多个 CDN 上，并开发一个加载Script的SDK集成到HTML中。当发现CDN资源加载失败时，逐步降级CDN域名。
A2：在前端发布服务中，增加HTML文本处理环节，如增加CDN域名替换，发生异常时，在发布服务中一键设置即可。


## chrome全屏截图

  F12 -> CTRL+SHIFT+P -> 输入 screen -> 选择capture full size screenshot。

## 检测用户空闲时间
  window.IdleDetector

## 85+的chrome支持读写文件
  这个太NB了
  