# 网络编程 - scoket编程（套接字编程）

## 分层架构
  应用层 - 传输层 - 网络层 - 数据链路层 -物理层

## TCP/IP协议 处在应用层
  * TCP: 传输控制协议，面向连接，可靠
  * UDP：用户数据报协议，无连接，不可靠
  > ip层，通过IP地址可以找到任意一台主机,
  > ip地址：32位无符号整型

## 进程寻址
  进程把数据给套接字 套接字把数据给TCP --> 因特网 --> tcp->套接字->进程

## TCP三次握手（主机A客户端，主机B服务端）
  * 主机A 请求链接 主机B, 发送syn报文 (确认主机A能发送信息)
  * 主机B 确认请求,发送synack报文       (确认主机B能收到主机A的信息，且主机B能发送信息)
  * 主机A 确认链接,发送ack报文       (确认主机A能收到主机B的信息)
  * 双方开启连接

## TCP四次分手（主机A客户端，主机B服务端）
  * 主机A发送FIN报文至主机B，
  * 主机B收到FIN报文，发送ACK报文
  * 主机B发送FIN报文
  * 主机A收到FIN报文，发送ACK报文，(等待一段时间后，关闭连接)
  * 主机B收到ACK报文，关闭连接
  > 主机A 最终发送ACK报文后，会等待一段时间（约两分钟）,
  > 1.证明主机B收到ACK报文，如果主机B没收到ACK报文，则会不停的向主机A发送FIN，
  > 2.等待主机B发送的报文可能因为网络延迟等原因还没被主机A收到

## SCOKET(c)
  `int socket(int domain, int type, int protocal)` 
  * domain 协议：http协议，本地协议，路由协议
  * type   套接字流：tcp或者udp
  * proticoiol
  




## 1
HTTP - TCP - IP - 链路层（硬件设备）

传输层 有TCP 面向链接的协议，UDP不面向连接的协议

MAC地址是唯一的，ip地址是可以分配的

## 2

通信协议就像双子塔 |_| 用户在顶层请求：从顶层到低，再从底层到顶

应用层（添加HTTP头） -> 传输层（添加TCP头） -> 网络层（添加IP头）-> 数据链路层（添加Mac头） -> 物理层

## 3

查看ip 在Windows上是```ipconfig```，在Linux上是```ifconfig```。

linux上还可以 ```ip addr```

每个网卡都会配一个ip地址，每台机器有多个网卡

## 4

DHCP协议主要是用来给客户租用IP地址


**交换机**

一个能把MAC头拿下来，检查一下目标MAC地址，然后根据策略转发的设备，我们称为交换机。

交换机怎么知道每个口的电脑的MAC地址呢？这需要交换机会学习。

一台MAC1电脑将一个包发送给另一台MAC2电脑，当这个包到达交换机的时候，一开始交换机也不知道MAC2的电脑在哪个口，所以没办法，它只能将包转发给除了来的那个口之外的其他所有的口。但是，这个时候，交换机会干一件非常聪明的事情，就是交换机会记住，MAC1是来自一个明确的口。以后有包的目的地址是MAC1的，直接发送到这个口就可以了。

当交换机作为一个关卡一样，过了一段时间之后，就有了整个网络的一个结构了，这个时候，基本上不用广播了，全部可以准确转发。当然，每个机器的IP地址会变，所在的口也会变，因而交换机上的学习的结果，我们称为转发表，是有一个过期时间的。

**TTL**

TTL是IP协议包中的一个值，代表IP包被路由器丢弃之前允许通过的最大网段数量，代表当前机器与目标机器之间要经过多少个路由器转发

**网关**

网关往往是一个路由器，是一个三层转发的设备、一个连接多网段的设备

三层设备就是把MAC头和IP头都取下来，然后根据里面的内容，看看接下来把包往哪里转发的设备。

人们把网关就叫作路由器。其实不完全准确，而另一种比喻更加恰当：路由器是一台设备，它有五个网口或者网卡，相当于有五只手，分别连着五个局域网。每只手的IP地址都和局域网的IP地址相同的网段，每只手都是它握住的那个局域网的网关。

**路由器**

路由器就是一台网络设备，它有多张网卡。当一个入口的网络包送到路由器时，它会根据一个本地的转发信息库，来决定如何正确地转发流量。这个转发信息库通常被称为路由表。

**socket**

在网络层，Socket函数需要指定到底是IPv4还是IPv6，分别对应设置为AF_INET和AF_INET6。另外，还要指定到底是TCP还是UDP。TCP协议是基于数据流的，所以设置为SOCK_STREAM，而UDP是基于数据报的，因而设置为SOCK_DGRAM。

**HTTP请求的发送**

HTTP协议是基于TCP协议的，所以它使用面向连接的方式发送请求，通过stream二进制流的方式传给对方。当然，到了TCP层，它会把二进制流变成一个的报文段发送给服务器。

在发送给每个报文段的时候，都需要对方有一个回应ACK，来保证报文可靠地到达了对方。如果没有回应，那么TCP这一层会进行重新传输，直到可以到达。同一个包有可能被传了好多次，但是HTTP这一层不需要知道这一点，因为是TCP这一层在埋头苦干。

TCP层发送每一个报文的时候，都需要加上自己的地址（即源地址）和它想要去的地方（即目标地址），将这两个信息放到IP头里面，交给IP层进行传输。

IP层需要查看目标地址和自己是否是在同一个局域网。
如果是，就发送ARP协议来请求这个目标地址对应的MAC地址，然后将源MAC和目标MAC放入MAC头，发送出去即可；
如果不在同一个局域网，就需要发送到网关，还要需要发送ARP协议，来获取网关的MAC地址，然后将源MAC和网关MAC放入MAC头，发送出去。

网关收到包发现MAC符合，取出目标IP地址，根据路由协议找到下一跳的路由器，获取下一跳路由器的MAC地址，将包发给下一跳路由器。

这样路由器一跳一跳终于到达目标的局域网。这个时候，最后一跳的路由器能够发现，目标地址就在自己的某一个出口的局域网上。于是，在这个局域网上发送ARP，获得这个目标地址的MAC地址，将包发出去。

目标的机器发现MAC地址符合，就将包收起来；发现IP地址符合，根据IP头中协议项，知道自己上一层是TCP协议，于是解析TCP的头，里面有序列号，需要看一看这个序列包是不是我要的，如果是就放入缓存中然后返回一个ACK，如果不是就丢弃。

TCP头里面还有端口号，HTTP的服务器正在监听这个端口号。于是，目标机器自然知道是HTTP服务器这个进程想要这个包，于是将包发给HTTP服务器。HTTP服务器的进程看到，原来这个请求是要访问一个网页，于是就把这个网页发给客户端。

**HTTPS**

http + ssl\tls tsl是升级版的ssl

**帧**

每一张图片，我们称为一帧。只要每秒钟帧的数据足够多，也即播放得足够快。比如每秒30帧，以人的眼睛的敏感程度，是看不出这是一张张独立的图片的，这就是我们常说的帧率（FPS）。

每一张图片，都是由像素组成的，假设为1024*768（这个像素数不算多）。每个像素由RGB组成，每个8位，共24位。

我们来算一下，每秒钟的视频有多大？

30帧 × 1024 × 768 × 24 = 566,231,040Bits = 70,778,880Bytes

**DNS**

DNS 有两个作用：
  * 域名解析
  * 负载均衡


DNS问题
  * 域名缓存问题

    > 它可以在本地做一个缓存，也就是说，不是每一个请求，它都会去访问权威DNS服务器，而是访问过一次就把结果缓存到自己本地，当其他人来问的时候，直接就返回这个缓存数据。
  * 域名转发问题
    > 如果是A运营商的客户，访问自己运营商的DNS服务器，如果A运营商去权威DNS服务器查询的话，权威DNS服务器知道你是A运营商的，就返回给一个部署在A运营商的网站地址，这样针对相同运营商的访问，速度就会快很多。

    > 但是A运营商偷懒，将解析的请求转发给B运营商，B运营商去权威DNS服务器查询的话，权威服务器会误认为，你是B运营商的，那就返回给你一个在B运营商的网站地址吧，结果客户的每次访问都要跨运营商，速度就会很慢
  * 出口NAT问题
    > 由于NAT(网络地址转换),使从当前网关出去的包转换成了新的IP地址，就有可能导致权威DNS服务器判断运营商错误，导致跨运营商访问
  * 域名更新问题
  * 解析延迟问题
    > DNS的查询过程需要递归遍历多个DNS服务器，才能获得最终的解析结果，这会带来一定的时延，甚至会解析超时。

HTTPNDS
  HTTPNDS其实就是，不走传统的DNS解析，而是自己搭建基于HTTP协议的DNS服务器集群，分布在多个地点和多个运营商。当客户端需要DNS解析的时候，直接通过HTTP协议进行请求这个服务器集群，得到就近的地址。用来解决传统DNS的问题

**CDN**

  用户发送请求的时候 如果DNS配置了CDN ，那么就会返回CDN的DNS给用户去访问。
  
  CDN也有边缘节点和区域节点、中心节点。

  CDN的缓存策略通常遵循http协议。

  如果CDN的缓存过期了就会回源服务器去请求新的，这称作回源。

**VPN**
  VPN，全名Virtual Private Network，虚拟专用网，就是利用开放的公众网络，建立专用数据传输通道，将远程的分支机构、移动办公人员等连接起来。


**BGP**
 边界网关协议







