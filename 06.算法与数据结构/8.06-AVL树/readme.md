# 平衡二叉排序树

平衡二叉排序树中最典型的就是红黑树

# AVL树 - 平衡二叉排序树

## 二叉排序树数据结构
二拆排序树的性质：左子树都小于根节点，右子树都大于根节点
二拆排序树的中序遍历：就是一个升序数列

## 二叉排序树删除操作
 删除度为0的节点：直接删除即可
 删除度为1的节点：直接删除，把子节点挂在父节点上即可
 删除度为2的节点：如下

  **二叉树中的前驱与后继**
  
  前驱：某个度为2的节点的左子树中的最后一个右子树，也就是中序遍历后本节点的上一个(左侧)值
  
  后继：某个度为2的节点的右子树中的最后一个左子树，也就是中序遍历后本节点的下一个(右侧)值
  > 前驱或者后继一定不是一个度为二的节点
  
  **删除操作**

  将前驱或者后继节点直接替换原节点，然后再去子树中删除前驱或者后继节点。**核心是把删除度为2的节点这个复杂问题，转化成了删除度为1或者0的节点这种简单问题**

**二叉排序被连续insert有序数据后，就退化成了一条链表**

## 为了解决二叉排序树的退化问题 - AVL：平衡二叉排序树出现了

> 平衡-左右子树的高度差不超过1

> 左旋与右旋天然的维护了二叉排序树的数据结构

**左旋**
将某一根节点A向左旋转 -> A的右节点C变成跟节点，A变成C的左节点，C的左节点D变成A的右节点,

左旋前
```js
node{
  key:A
  left:{key:B}
  right:{
    key:C
    left:D
    right:E
  }
}
```
左旋后
```js
node{
  key:C
  left:{key:A,left:B,right:D}
  right:{
    key:E
  }
}
```
**右旋**
与左旋正相反

## 二叉排序树失衡的四种类型
> 失衡时，树的深度为3，小旋为第二层旋转， 大旋为第一层旋转

LL型 - 由一次大右旋即可解决

LR型 - 先进行一次小左旋，整体变成LL型失衡，再大右旋即可

RR型 - 由一次大左旋即可

RL型 - 先进行一次小右旋，整体变成RR型失衡，再大左旋即可

